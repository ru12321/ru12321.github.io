{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Mr.Ru",
  "home_page_url": "https://mister-hope.github.io/",
  "feed_url": "https://mister-hope.github.io/feed.json",
  "description": "Mr.Ru的博客",
  "icon": "https://mister-hope.github.io/logo.svg",
  "authors": [
    {
      "name": "Mr.Ru",
      "url": "https://github.com/ru12321"
    }
  ],
  "items": [
    {
      "title": "关于博客",
      "url": "https://mister-hope.github.io/about_me/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2.html",
      "id": "https://mister-hope.github.io/about_me/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2.html",
      "summary": "写在前面 本博客依赖vuepress-theme-hope主题模板进行搭建，依照官方教程做了些自定义的配置，大致符合自己简洁、清晰的审美理念，就直接上线了。此文档更多的是整体搭建和详细部署的说明，对自定义配置各位参照文档，一两个小时也就搞定了~ 助力每一个想要搭建自己博客的少男少女，愿你少踩点非必要的坑~ 博客相关内容持续集成中，欢迎关注交流！！ 博客搭建 官网有小白教程可以大致参考，多余的不再重复~~",
      "content_html": "<h2> 写在前面</h2>\n<p>本博客依赖<code>vuepress-theme-hope</code>主题模板进行搭建，依照官方教程做了些自定义的配置，大致符合自己简洁、清晰的审美理念，就直接上线了。此文档更多的是整体搭建和详细部署的说明，对自定义配置各位参照文档，一两个小时也就搞定了~</p>\n<p>助力每一个想要搭建自己博客的少男少女，愿你少踩点非必要的坑~</p>\n<p>博客相关内容持续集成中，欢迎关注交流！！</p>\n<h2> 博客搭建</h2>\n<p>官网有<a href=\"https://vuepress-theme-hope.gitee.io/v2/zh/cookbook/tutorial/\" target=\"_blank\" rel=\"noopener noreferrer\">小白教程</a>可以大致参考，多余的不再重复~~</p>\n<h3> 1.运行环境</h3>\n<p>idea + Node.js + pnpm</p>\n<ul>\n<li>\n<p>idea：选择它作为开发工具只有一个原因，那就是习惯了~~官方推荐vscode会有更多的语法提示，但不会使用的配置还是要自己去读文档，提示作用不大，而且idea也有一些提示的；</p>\n</li>\n<li>\n<p>node.js：版本选择的是<code>v16.16.0</code>，大于等于该版本应该均可；</p>\n</li>\n<li>\n<p>pnpm：版本选择的是<code>7.28.0</code>，推荐用它管理项目，比npm速度快、节省空间；</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h3> 2.创建项目</h3>\n<p>找到本机要存放项目的位置，创建文件夹（最好英文），直接cmd在终端输入</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接着一路选择，记得选择<code>pnpm</code>，然后自动部署文档输入<code>y</code>（后面会用到）</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549257.png\" alt=\"image-20230311133146598\" loading=\"lazy\"></p>\n<p>安装好依赖后，会提示输入y查看博客网址</p>\n<ul>\n<li>\n<p>意外情况：输入y出现报错，这个极有可能是vuepress-theme-hope的版本问题，解决方式就是指定该项目的<a href=\"https://github.com/vuepress-theme-hope/vuepress-theme-hope/releases\" target=\"_blank\" rel=\"noopener noreferrer\">版本号</a></p>\n<p>选择github中最新的版本或之前稳定的某版本，再次尝试</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h3> 3.启动项目</h3>\n<p>进入项目终端下输入<code>pnpm docs:dev</code></p>\n<ul>\n<li>如果不出意外，就可以在本机8080端口访问了，当然你也可以修改端口号，在package.json文件修改命令</li>\n</ul>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 博客部署</h2>\n<p>请注意：下面要写的是整个博客的<code>自动部署</code>，并非一次简单的手动部署，所以按需食用</p>\n<h3> step1.上传项目</h3>\n<ul>\n<li>\n<p>github新建仓库，命名要为<code>用户名.github.io</code>，如我的github用户名为ru12321，那么此次新仓库命名为<code>ru12321.github.io</code>，仓库地址如图获取</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549427.png\" alt=\"image-20230311135650669\" loading=\"lazy\"></p>\n</li>\n<li>\n<p><a href=\"http://xn--deploy-9v7iw71aui2c7ho8gxslxr3em80e9yxa.sh\" target=\"_blank\" rel=\"noopener noreferrer\">项目中添加部署脚本deploy.sh</a></p>\n<p>脚本作用：构建项目、将dist下的所有文件由本地的master分支提交到远端仓库<code>ru12321.github.io</code>的<code>gh-pages分支</code></p>\n<p>你要做的：修改仓库地址为自己的即可，远端分支gh-pages命名不要改！</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>执行deploy.sh脚本，进入到脚本位置，右键使用git打开</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549114.png\" alt=\"image-20230311135217147\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>执行脚本<code>sh deploy.sh</code>，上传项目打包文件到远端github.io仓库</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549446.png\" alt=\"image-20230311135303902\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>上传完成后，github pages模块就会触发部署，自动生成你的网站</p>\n<p>如图，去仓库的对应位置，就可以通过这个域名访问自己的网站了</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549896.png\" alt=\"image-20230311135904991\" loading=\"lazy\"></p>\n<p>总结，以上通过deploy.sh脚本实现了<code>项目的构建、上传构建后文件到远端github仓库gh-pages分支、触发pages构建网站</code>，博客网站到此就可以通过<code>https://用户名.github.io</code>域名访问了。但是想想以后你每次修改了博客内容，都要手动去执行下deploy.sh脚本更新你的网站，是不是有点麻烦呢？所以有了接下来自动部署的步骤</p>\n<h3> step2 项目上传</h3>\n<p>为了方便使用github管理项目，及更好的利用github的actions机制，需要上传整个项目到远端<code>用户名.github.io</code>的master主分支上。这样做的目的是，之后每次本地修改了博客内容，通过push到github远端，都会进行后续一系列的自动更新网站，实现自动部署的效果~~</p>\n<ul>\n<li>\n<p>push整个项目内容到远端的master分支上，会git的应该都懂吧。</p>\n<p>中间可能需要登录下github、输入下远端仓库的地址~</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549359.png\" alt=\"image-20230311141326887\" loading=\"lazy\"></p>\n<p>至此，远端仓库有了两个分支</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549945.png\" alt=\"image-20230311141617167\" loading=\"lazy\"></p>\n<p>master：管理整个博客项目使用</p>\n<p>gh-pages：存放的是博客构建后的所有文件，用来通过pages模块生成博客网站</p>\n<h3> step3.修改workflows脚本</h3>\n<p>说明一下：本质就是通过github的actions模块，自动监测项目master分支的变动，然后执行actions的workflows的脚本，依然是<code>项目构建、自动更新代码文件到gh-pages分支上、自动触发pages构建网站</code>，所以重点就是workflows工作流的脚本的编写和相应的配置了</p>\n<p>不出意外的话，项目本身会有<code>.github/workflows/deplooy-docs.yml</code>这个文件，它就是我们需要的脚本！</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上需要修改和注意的地方有三个，其它地方可以对比下，应该不需要改动</p>\n<ol>\n<li>第7行的分支名称：就是我们step2上传的远端分支名称，如master</li>\n<li>第16行<code>fetch-depth: 0</code> 检测分支用的</li>\n<li>第40行 先这样写，接下来说明这一行token的配置</li>\n</ol>\n<h3> step4.生成token</h3>\n<p>上面的token是为了在触发actions自动部署时，action<strong>有权限去切换到gh-pages分支并更新其内容</strong>，所以是必要的！</p>\n<h4> 配置1  生成token</h4>\n<p>点击github右上角头像--<code>settings</code>--<code>developer settings</code>--<code>personal access tokens</code>--<code>token(classic)</code>--<code>generate new token</code>--<code>generate new token(classic)</code></p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549230.png\" alt=\"image-20230311142430423\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>输入密码弹出页面</p>\n<p>输入Note名称为<code>ACCESS_TOKEN</code>  对应上面workflows脚本的那个值</p>\n<p>设定token到期时间、</p>\n<p>勾选token作用范围 repo即可</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549027.png\" alt=\"image-20230311142714721\" loading=\"lazy\"></p>\n<ul>\n<li>点击<code>generate token</code> 生成秘钥</li>\n<li>保存复制一串数字+字母组合，如<code>ghp_vzoGj02I0dqwueykhflwZv6Cq4r05q4aN</code>后面会用到</li>\n</ul>\n<h4> 配置2 在仓库配置</h4>\n<ul>\n<li>如图，新建一个secret，命名为<code>ACCESS_TOKEN</code>，值为上面的一串神秘组合</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549209.png\" alt=\"image-20230311143235520\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>操作完后就会生成一个secret</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549028.png\" alt=\"image-20230311143502963\" loading=\"lazy\"></p>\n</li>\n</ul>\n<h3> step5.额外配置</h3>\n<p>仓库的settings--<code>Actions</code>--<code>General</code></p>\n<p>如图，修改两个选项为workflows增加操作仓库的权限，修改完记得分部点下save</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549274.png\" alt=\"image-20230311143938914\" loading=\"lazy\"></p>\n<hr>\n<hr>\n<hr>\n<h3> step6.测试一下</h3>\n<p>至此，完成了博客的自动部署配置，可以本地修改某个md文件内容，上传到远端master分支，看看有没有自动出发pages自动更新网站内容呢？actions触发成功会显示为绿色，失败也会有相应的日志可以查看。</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549685.png\" alt=\"image-20230311144241070\" loading=\"lazy\"></p>\n<h2> 写在最后</h2>\n<p>初次尝试搭建博客，过程中有其它问题也欢迎交流，评论（留下邮箱）即可~</p>\n",
      "image": "https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549257.png",
      "date_published": "2023-03-11T00:00:00.000Z",
      "date_modified": "2023-03-19T10:32:40.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "我"
      ]
    },
    {
      "title": "frontmatter说明",
      "url": "https://mister-hope.github.io/example.html",
      "id": "https://mister-hope.github.io/example.html",
      "summary": "测试页面，用来记录一些页面配置 index: false 不展示在侧边栏，不收集到children中 comment: false 不显示评论",
      "content_html": "<p>测试页面，用来记录一些页面配置</p>\n<p>index: false  不展示在侧边栏，不收集到children中\ncomment: false  不显示评论</p>\n",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-03-19T10:32:40.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "计算机"
      ]
    },
    {
      "title": "who am i？",
      "url": "https://mister-hope.github.io/about_me/",
      "id": "https://mister-hope.github.io/about_me/",
      "summary": "info标题 我是info内容 一个平平无奇的碳基生物",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">info标题</p>\n<p>我是info内容</p>\n</div>\n<p>一个平平无奇的碳基生物</p>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-10T10:18:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": []
    },
    {
      "title": "我的爱好",
      "url": "https://mister-hope.github.io/about_me/%E6%88%91%E7%9A%84%E7%88%B1%E5%A5%BD.html",
      "id": "https://mister-hope.github.io/about_me/%E6%88%91%E7%9A%84%E7%88%B1%E5%A5%BD.html",
      "summary": "相关信息 就是玩儿",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">相关信息</p>\n<p>就是玩儿</p>\n</div>\n",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-03-10T10:18:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "我"
      ]
    },
    {
      "title": "书斋",
      "url": "https://mister-hope.github.io/book/",
      "id": "https://mister-hope.github.io/book/",
      "summary": "读过的书~hhhh test2 test3 test4 test5",
      "content_html": "<p>读过的书~hhhh\ntest2\ntest3\ntest4\ntest5</p>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-11T04:39:07.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": []
    },
    {
      "title": "江湖",
      "url": "https://mister-hope.github.io/essay/",
      "id": "https://mister-hope.github.io/essay/",
      "summary": "一点点",
      "content_html": "<p>一点点</p>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-10T10:18:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "生活"
      ]
    },
    {
      "title": "窄门",
      "url": "https://mister-hope.github.io/tech/",
      "id": "https://mister-hope.github.io/tech/",
      "summary": "相关信息 近期正在学习的技术点和遇到的问题",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">相关信息</p>\n<p>近期正在学习的技术点和遇到的问题</p>\n</div>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-19T10:32:40.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": []
    },
    {
      "title": "jdk8新特性",
      "url": "https://mister-hope.github.io/tech/java/jdk%E6%96%B0%E7%89%B9%E6%80%A7.html",
      "id": "https://mister-hope.github.io/tech/java/jdk%E6%96%B0%E7%89%B9%E6%80%A7.html",
      "summary": "学习资料 https://blog.csdn.net/LXYDSF/article/details/125919046 一、Stream新特性 Stream概念 java.util.stream包 Stream 是Java8 中处理集合的关键抽象概念，它可以对集合执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。 Stream API 提供了一种高效且易于使用的处理数据的方式。 Stream 和Collection 集合的区别：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算。 集合讲的是数据，关注的是数据的存储，与内存打交道 Stream 讲的是计算，关注的是对数据的运算，与CPU打交道 Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream 。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。",
      "content_html": "<p>学习资料 <a href=\"https://blog.csdn.net/LXYDSF/article/details/125919046\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/LXYDSF/article/details/125919046</a></p>\n<h1> 一、Stream新特性</h1>\n<h2> Stream概念</h2>\n<p>java.util.stream包</p>\n<ul>\n<li>\n<p>Stream 是Java8 中<strong>处理集合</strong>的关键抽象概念，它可以对集合执行非常复杂的查找、过滤和映射数据等操作。<strong>使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询</strong>。</p>\n</li>\n<li>\n<p>Stream API 提供了一种高效且易于使用的处理数据的方式。</p>\n<ul>\n<li><strong>Stream 和Collection 集合的区别</strong>：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算。</li>\n</ul>\n</li>\n<li>\n<p><strong><mark>集合讲的是数据，关注的是数据的存储，与内存打交道</mark></strong></p>\n</li>\n<li>\n<p><strong><mark>Stream 讲的是计算，关注的是对数据的运算，与CPU打交道</mark></strong></p>\n</li>\n<li>\n<p>Stream是<mark>数据渠道</mark>，用于操作数据源（集合、数组等）所生成的元素序列。</p>\n<ul>\n<li>Stream 自己不会存储元素。</li>\n<li>Stream 不会改变源对象。相反，他们会<em>返回一个持有结果的新 Stream</em> 。</li>\n<li>Stream 操作是延迟执行的。这意味着他们会等到<em>需要结果的时候才执行</em>。</li>\n</ul>\n</li>\n</ul>\n<h2> Stream操作</h2>\n<h3> 1 操作步骤</h3>\n<ol>\n<li>创建 Stream 一个数据源（如：集合、数组），获取一个</li>\n<li>中间操作（<strong>非必要</strong>） 一个中间操作链，对数据源的数据进行处理</li>\n<li>终止操作 一旦执行 终止操作， 就 执行中间操作链 ，并产生结果 。之后，不会再被使用</li>\n</ol>\n<h3> 2 创建</h3>\n<h4> <strong>2.1 通过集合</strong></h4>\n<p>最常见！ 集合.stream()</p>\n<p>Java8中的 Collection 接口被扩展，提供了两个获取流的方法<code>.stream()</code>，<code>.parallelStream()</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2.2 Arrays.stream()</h4>\n<p>Java8中的 Arrays 的静态方法 <code>Arrays.stream()</code> 可以获取数组流：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>重载形式，能够处理对应基本类型的数组：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2.3 Stream.of()</h4>\n<p>可以调用Stream 类静态方法<code>Stream.of()</code> , 通过显示值创建一个流。它可以接收任意数量的参数。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2.4 无限流</h4>\n<p>可以使用Stream 类静态方法<code>Stream.iterate()</code> 和 <code>Stream.generate()</code>，创建无限流。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3 中间操作</h3>\n<p>多个<strong>中间操作</strong> 可以连接起来形成一个 <strong>流水线</strong> ，除非流水线上触发终止操作，否则 <strong>中间操作不会执行任何的处理</strong> ！而在 <mark><em>终止操作时一次性全部处理</em></mark>，称为“惰性求值” 。</p>\n<h4> 3.1 筛选与切片</h4>\n<ul>\n<li>\n<p><strong>filter(Predicate p)：接收Lambda ，获得满足条件P（断定型接口 返回Boolean值）的元素</strong></p>\n</li>\n<li>\n<p><strong>distinct()：去除重复元素（同一个内存地址的）</strong></p>\n</li>\n<li>\n<p><strong>limit(long maxSize)：截断流，使其元素不超过给定数量</strong></p>\n</li>\n<li>\n<p>skip(long n)：跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与<code>limit(n)</code>互补</p>\n</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.2 映射</h4>\n<ul>\n<li><strong>map(Function f)：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</strong></li>\n<li>mapToDouble(ToDoubleFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。</li>\n<li>mapToInt(ToIntFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。</li>\n<li>mapToLong(ToLongFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。</li>\n<li>flatMap(Function f)：接收一个函数作为参数，将流中的每个值都换成另一个流，<strong>然后把所有流连接成一个流</strong></li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.3 排序</h4>\n<ul>\n<li><strong>sorted()：产生一个新流，其中按自然顺序排序</strong></li>\n<li>sorted(Comparator com)：产生一个新流，其中按比较器顺序排序</li>\n</ul>\n<h3> 4 终止操作</h3>\n<ul>\n<li>\n<p><mark>流不一定需要中间操作，可以直接创建--&gt;终止操作</mark></p>\n</li>\n<li>\n<p>终端操作<strong>会从流的流水线生成结果</strong>。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 。</p>\n</li>\n<li>\n<p>流进行了终止操作后，不能再次使用。</p>\n</li>\n</ul>\n<h4> 4.1 匹配与查找</h4>\n<ul>\n<li>\n<p>allMatch(Predicate p)：检查是否匹配所有元素</p>\n</li>\n<li>\n<p><strong>anyMatch(Predicate p)：检查是否至少匹配一个元素</strong></p>\n</li>\n<li>\n<p>noneMatch(Predicate p)：检查是否没有匹配所有元素</p>\n</li>\n<li>\n<p><strong>findFirst()：返回第一个元素</strong></p>\n</li>\n<li>\n<p>findAny()：返回当前流中的任意元素</p>\n</li>\n<li>\n<p>count()：返回流中元素总数</p>\n</li>\n<li>\n<p>max(Comparator c)：返回流中最大值。参数是比较器，比如Comparator.comparing(String::length)</p>\n</li>\n<li>\n<p>min(Comparator c)：返回流中最小值。</p>\n</li>\n<li>\n<p><strong>forEach(Consumer c)：内部迭代</strong></p>\n</li>\n</ul>\n<h4> 4.2 reduce 归约</h4>\n<p>归约：将一个Stream中的所有元素反复结合起来,得到一个结果</p>\n<p>备注：map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。</p>\n<ul>\n<li>reduce(T iden, BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。返回T</li>\n<li>reduce(BinaryOperator b)：参数是二元函数。可以将流中元素反复结合起来，得到一个值。<mark>返回Optional对象</mark>，</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.3 收集</h4>\n<ul>\n<li>collect(Collector c)：将流转换为<mark>其他形式（如List 、 Set 、Map等）</mark>。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</li>\n</ul>\n<p>Collector接口中方法的实现决定了如何对流执行收集的操作 如收集到 List 、 Set 、Map。</p>\n<p>另外，Collectors 实用类提供了很多<strong>静态方法</strong>，可以方便地创建常见收集器实例</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171547597.png\" alt=\"image-20230317154719527\" loading=\"lazy\"></p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171547592.png\" alt=\"image-20230317154727522\" loading=\"lazy\"></p>\n<h1> 二、Lambda表达式</h1>\n<p>Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（<mark>将代码像数据一样进行传递</mark>）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>\n<ul>\n<li>好处：避免匿名内部类定义过多，可以让代码简洁紧凑，留下核心的逻辑</li>\n</ul>\n<ul>\n<li>\n<p>Lambda表达式特征</p>\n<ul>\n<li>**可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。</li>\n<li>**可选的参数圆括号：**一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>\n<li>**可选的大括号：**如果主体包含了一个语句，就不需要使用大括号。</li>\n<li>**可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>\n</ul>\n</li>\n<li>\n<p>注意：lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>\n</li>\n</ul>\n<h1> 三、函数式接口</h1>\n<h2> 1 函数式接口概念</h2>\n<ul>\n<li>\n<p>定义：<mark>只包含一个抽象方法的接口</mark></p>\n</li>\n<li>\n<p>使用 <code>@FunctionalInterface</code> 注解<strong>用来测试用</strong>，如果不是函数式接口，那么会报错；</p>\n<ul>\n<li>只要满足函数式接口的定义，<em>这个注解写不写无所谓</em></li>\n</ul>\n</li>\n<li>\n<p>可以通过 <code>Lambda </code>表达式来创建该接口的对象</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>java 不但可以支持 OOP 还可以支持 OOF （面向函数编程），<mark>将函数作为参数，进行传递</mark></p>\n</li>\n<li>\n<p>在 Java8 中， <code>Lambda</code> 表达式就是一个函数式接口的实例</p>\n</li>\n</ul>\n<h2> 2 Java内置的函数式接口</h2>\n<blockquote>\n<p><strong>一定要注意这些函数参数类型什么，返回类型是什么</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>函数式接口</th>\n<th>参数类型</th>\n<th>返回类型</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Consumer&lt;T&gt;</code></td>\n<td><mark>T</mark></td>\n<td><mark>void</mark></td>\n<td>对类型为T的对象应用操作，包含方法：<code>void accept(T t)</code></td>\n</tr>\n<tr>\n<td><code>Supplier&lt;T&gt;</code></td>\n<td><mark>无</mark></td>\n<td><mark>T</mark></td>\n<td>返回类型为T的对象，包含方法：<code>T get()</code></td>\n</tr>\n<tr>\n<td><code>Function&lt;T, R&gt;</code></td>\n<td><mark>T</mark></td>\n<td><mark>R</mark></td>\n<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)</code></td>\n</tr>\n<tr>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><mark>T</mark></td>\n<td><mark>boolean</mark></td>\n<td>确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：<code>boolean test(T t)</code></td>\n</tr>\n</tbody>\n</table>\n<p>总结：<strong>遇到方法参数类型为以上接口时，可以使用lambda表达式进行优化</strong></p>\n<h3> 2.1 消费型接口 Consumer&lt; T&gt;     void accept(T t)</h3>\n<ul>\n<li><mark><strong>在lambda中使用：T类型参数，无需返回数据</strong></mark></li>\n</ul>\n<p><strong>消费一个指定泛型的数据</strong>（至于具体怎么消费(使用), 需要自定义(输出，计算…） 其数据类型由泛型决定。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.2 生产型接口 Supplier&lt; T&gt;      T get()</h3>\n<ul>\n<li>\n<p><mark><strong>在lambda中使用：无参，返回T类型数据 即可</strong></mark></p>\n</li>\n<li>\n<p>生产型接口，指定接口的泛型是什么类型，那么接口中的get方法<strong>就会生产什么类型的数据</strong></p>\n</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.3 函数型接口 Function&lt;T, R&gt;      R  apply(T t)</h3>\n<ul>\n<li><mark><strong>在lambda中使用：T类型参数，返回R类型数据 即可</strong></mark></li>\n</ul>\n<p>来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.4 断定型接口 Predicate&lt; T&gt;       boolean   test(T t)</h3>\n<p><mark><strong>在lambda中使用：T类型参数，返回boolean类型数据 即可</strong></mark></p>\n<p><strong>对某种类型的数据进行判断</strong>，得到一个boolean值结果</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 四、方法引用与构造器引用</h1>\n<h2> 4.2</h2>\n<h3> 1 方法引用</h3>\n<ul>\n<li>\n<p>使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>\n</li>\n<li>\n<p><strong>通过方法的名字来指向一个方法</strong>，可以认为是Lambda表达式的一个语法糖</p>\n</li>\n<li>\n<p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</p>\n</li>\n<li>\n<p>格式：<code>类(或对象) :: 方法名</code></p>\n</li>\n<li>\n<p>如下三种主要使用情况：</p>\n<ul>\n<li>对象 :: 实例方法名</li>\n<li>类 :: 静态方法名</li>\n<li>类 :: 实例方法名</li>\n</ul>\n</li>\n</ul>\n<h3> 2 构造器引用</h3>\n<p>格式：ClassName :: new //构造器引用</p>\n<p>格式：type[] :: new //数组引用</p>\n<h1> 五、Optional类</h1>\n<p><a href=\"https://www.runoob.com/java/java8-optional-class.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/java/java8-optional-class.html</a></p>\n<h3> 1 概述</h3>\n<ul>\n<li>\n<p>本质上，这是一个<mark>包含有可选值</mark>的包装类</p>\n</li>\n<li>\n<p>Optional 类是一个<strong>可以为null的容器对象</strong>。<mark><strong>如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></mark></p>\n</li>\n<li>\n<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就<strong>不用显式进行空值检测</strong>。Optional\n类的引入很好的解决空指针异常（NullPointerException）。</p>\n</li>\n</ul>\n<h3> 2 创建optional实例</h3>\n<ul>\n<li>使用静态方法<strong>empty()<strong>创建一个</strong>空的Optional对象</strong></li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>明确对象不为null</strong> 的时候使用<strong>of()</strong>，<strong>包含值</strong>的对象</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>如果对象即<strong>可能是null也可能是非 null</strong>，你就应该使用**ofNullable()**方法，<strong>包含值</strong>的对象</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 3 访问对象的值</h3>\n<ul>\n<li><strong>get()方法</strong></li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>检查是否有值的另一个选择是 ifPresent()方法</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4 返回默认值</h3>\n<ul>\n<li><strong>orElse()</strong>：如果有值则返回该值user，否则返回传递给它的参数值user2</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>orElseGet()—— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的**Supplier(供应者)**函数式接口，并将返回其执行结果：</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 5.map()方法</h3>\n",
      "image": "https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171547597.png",
      "date_published": "2022-02-02T00:00:00.000Z",
      "date_modified": "2023-03-19T10:32:40.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "java"
      ]
    }
  ]
}