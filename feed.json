{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Mr.Ru",
  "home_page_url": "https://mister-hope.github.io/",
  "feed_url": "https://mister-hope.github.io/feed.json",
  "description": "Mr.Ru的博客",
  "icon": "https://mister-hope.github.io/logo.svg",
  "authors": [
    {
      "name": "Mr.Ru",
      "url": "https://github.com/ru12321"
    }
  ],
  "items": [
    {
      "title": "docker",
      "url": "https://mister-hope.github.io/tech/ops/Docker.html",
      "id": "https://mister-hope.github.io/tech/ops/Docker.html",
      "summary": "教程网址 命令大全 https://blog.csdn.net/anqixiang/article/details/114001509 Docker中文文档https://vuepress.mirror.docker-practice.com/basic_concept/container/",
      "content_html": "<h2> 教程网址</h2>\n<p>命令大全 <a href=\"https://blog.csdn.net/anqixiang/article/details/114001509\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/anqixiang/article/details/114001509</a></p>\n<p>Docker中文文档<a href=\"https://vuepress.mirror.docker-practice.com/basic_concept/container/\" target=\"_blank\" rel=\"noopener noreferrer\">https://vuepress.mirror.docker-practice.com/basic_concept/container/</a></p>\n<h2> 1.什么是docker</h2>\n<p>Docker 是使用最广泛的开源容器引擎，它彻底释放了计算虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本！ 使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！</p>\n<p>Docker 使用 <strong>Google 公司推出的 Go 语言</strong> 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。<strong>由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</strong></p>\n<p><mark>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</mark></p>\n<h2> 2.为什么用docker</h2>\n<p>① 更高效的利用系统资源：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</p>\n<p>② 更快速的启动时间：Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。</p>\n<p>③ 一致的运行环境：Docker 的镜像提供了除内核外完整的运行时环境，<strong>确保了应用运行环境一致性</strong>。</p>\n<p>④ 持续交付和部署：使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。一次创建或配置，可以在任意地方正常运行。</p>\n<p>⑤ 更轻松的迁移：Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。</p>\n<h2> 3.docker隔离原理</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/519499603\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/519499603</a></p>\n<p><mark>容器是一种对进程进行隔离的运行环境</mark></p>\n<p>一个容器进程本质上是一个运行在沙盒中的隔离进程，由Linux系统本身负责隔离，Docker只是提供了一系列工具，帮助我们设置好隔离环境后，启动这个进程。</p>\n<h3> 1.进程隔离</h3>\n<p>最基本的隔离就是进程之间看不到彼此，这是由<strong>Linux的Cgroup机制</strong>实现的。进程隔离的结果就是<strong>以隔离方式启动的进程看到的自身进程ID总是1，且看不到系统的其他进程</strong>。</p>\n<h3> 2.文件系统隔离</h3>\n<p>Docker利用<strong>Linux的mount机制</strong>，<strong>给每个隔离进程挂载了一个虚拟的文件系统</strong>，使得一个隔离进程只能访问这个虚拟的文件系统，无法看到系统真实的文件系统。至于这个虚拟的文件系统应该长什么样，这就是制作Docker镜像要考虑的问题。比如我们的Python程序要正常运行，需要一个Python3解释器，需要把用到的第三方库如<code>psutil</code>引入进来，这些复杂的工作被简化为一个<code>Dockerfile</code>，再由Docker把这些运行时的依赖打包，就形成了Docker镜像。我们可以把一个Docker镜像看作一个zip包，每启动一个进程，Docker都会自动解压zip包，把它变成一个虚拟的文件系统。</p>\n<h3> 3.网络协议栈隔离</h3>\n<p>我们举个例子：在Docker中运行<code>docker run redis:latest</code>，然后在宿主机上写个程序连接<code>127.0.0.1:6379</code>，是无法连接到Redis的，因为Redis虽然监听<code>127.0.0.1:6379</code>这个端口，但Linux可以为进程隔离网络，Docker默认启动的Redis进程拥有自己的网络名字空间，与宿主机不同：</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201501619.webp\" alt=\"img\" loading=\"lazy\"></p>\n<p>要让宿主机访问到Redis，可以用<code>-p 6379:6379</code>把Redis进程的端口号映射到宿主机，从而在宿主机上访问Redis：</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201501660.webp\" alt=\"img\" loading=\"lazy\"></p>\n<p>因此，在Linux的网络名字空间隔离下，Redis进程和宿主机进程看到的IP地址<code>127.0.0.1</code>表面上一样，但实际上是不同的网络接口。</p>\n<p>我们再看一个更复杂的例子。如果我们要运行ZooKeeper和Kafka，先启动ZooKeeper：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>再启动Kafka，发现Kafka是无法连接ZooKeeper的，原因是，Kafka试图连接的<code>127.0.0.1:2181</code>在它自己的网络接口上并不存在：</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201501077.webp\" alt=\"img\" loading=\"lazy\"></p>\n<p>必须连接到ZooKeeper的<code>IP:2181</code>或者宿主机的<code>IP:2181</code>。直接指定IP并不是一个好的方式，我们应该利用Docker Compose，把ZooKeeper和Kafka运行在同一个网络名字空间里，并通过<code>zookeeper:2181</code>来访问ZooKeeper端口，让Docker自动把zookeeper名字解析为动态分配的IP地址。</p>\n<h2> 4.docker组成</h2>\n<h3> 镜像(Images)</h3>\n<p>Docker 镜像是一个特殊的文件系统，除了<strong>提供容器运行时所需的程序、库、资源、配置</strong>等文件外，还包含了一些<strong>为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）</strong>。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<p>Docker 设计时，充分利用 Union FS 的技术，将其设计为分层存储的架构，Docker 镜像由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p>\n<hr>\n<h4> docker的镜像原理</h4>\n<h4> 镜像是什么？</h4>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h4> 为什么一个镜像会那么大？</h4>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>\n<p>UnionFS（联合文件系统）:</p>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>\n</li>\n</ul>\n<h4> Docker镜像原理</h4>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。<strong>因此不同的发行版可以共用bootfs。</strong></p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201501323.png\" alt=\"image-20221228104808238\" loading=\"lazy\"></p>\n<h4> 为什么docker镜像要采用这种分层结构呢?</h4>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<p>比如：<strong>有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享</strong>。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</p>\n<h3> 容器(Container)</h3>\n<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p><strong>容器的实质是进程</strong>，但与直接在宿主执行的进程不同，<strong>容器进程运行于属于自己的独立的 命名空间</strong>。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p>\n<p><mark>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层</mark>，我们可以称这个为容器运行时读写而准备的存储层为<mark>容器存储层</mark>。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化</strong>。所有的文件写入操作，都应该<mark>使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层</mark>，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>\n<p><strong>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p>\n<h3> 镜像仓库(Registry)</h3>\n<p>镜像仓库是一个集中的存储、分发镜像的服务。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。\n通常，<strong>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本</strong>。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt; </code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>\n<p>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p>\n<h2> 5.全局命令</h2>\n<p><code>service docker start</code>：wsl2启动docker： （必须在root下！ sudo su -）</p>\n<p><code>docker -v</code> ：查看docker版本</p>\n<p><code>docker info</code> : 显示 Docker 系统信息，包括镜像和容器数</p>\n<p><code>docker login --username=zhangb-l@bimcop registry.cn-beijing.aliyuncs.com</code>  设置登录公司镜像</p>\n<p>密码  glodonUser123!@#</p>\n<h2> 6.镜像命令</h2>\n<p><code>docker image ls tomcat</code> 根据仓库名列出部分镜像</p>\n<p><code>docker images</code> 查看本地所有镜像</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>docker images -q</code> 查看本地镜像的所有镜像id</p>\n<p><code>docker load -i nginx.tar</code>\t      \t 导入nginx镜像，-i就是input</p>\n<p><code>docker load &lt; nginx.tar</code>\t      \t\t导入nginx镜像</p>\n<p><code>docker login -u 用户名 -p密码 镜像仓库地址</code>\t\t 登录镜像仓库</p>\n<p><code>docker push 镜像仓库地址/镜像名:Tag</code>   \t推送镜像到远程镜像仓库</p>\n<p><code>docker rmi 镜像名[:Tag]</code>\t删除镜像</p>\n<p><code>docker rmi 镜像ID</code>\t\t          删除镜像</p>\n<p><code>docker rmi -f 镜像ID</code>\t\t   强制删除镜像（如果容器已经启动则需先停止后方可删除）</p>\n<p><code>docker rmi -f $(docker images -aq)</code>\t\t批量删除所有镜像（$后作为参数传递）</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>docker save 镜像名:Tag &gt; 镜像名-tag.tar</code>\t\t\t把镜像打成一个tar包（推荐tar包命名为镜像名-tag），-o代表output</p>\n<p><code>docker save 镜像名:Tag -o 镜像名-tag.tar</code>\t\t\t把镜像打成一个tar包</p>\n<p><code>docker search 镜像名[:Tag]</code>  搜索镜像，默认从dockerhub搜索</p>\n<p><code>docker system df</code>查看镜像、容器、数据卷所占用的空间</p>\n<p><code>docker system prune -a</code>\t\t               \t\t\t删除没有任何容器使用的镜像、构建缓存</p>\n<p><code>docker pull 镜像名[:Tag]</code> 下载镜像；不指定Tag，默认为latest</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>docker tag 镜像名:Tag</code> \t                        \t\t给镜像打Tag</p>\n<h2> 7.容器命令</h2>\n<ul>\n<li>每一个容器都是一个精简版的linux系统，里面运行着一个服务</li>\n</ul>\n<hr>\n<p><code>docker ps</code> 查看正在运行的容器</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>docker ps -a</code> 查看所有容器</p>\n<p><code>docker ps -q</code> 返回正在运行容器id</p>\n<p><code>docker ps -aq</code> 返回所有容器id</p>\n<p><code>docker run -d -p 8081:8080 --name=tomcat_ruyb tomcat:8.0</code> 启动容器</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>docker stop 容器名或容器id</code> 正常停止容器运行</p>\n<p><code>docker kill 容器名或容器id</code> 立即停止容器运行</p>\n<p><code>docker rm 容器名或容器id</code>\t\t      删除容器</p>\n<p><code>docker rm -f 容器名</code>\t\t\t\t\t      强制删除容器，可以删除运行中的容器</p>\n<p><code>docker exec -it 容器ID bash</code>\t进入容器，并分配一个新的终端</p>\n<p><code>docker top 容器名或容器id</code>          查看容器内的进程</p>\n<p><code>docker inspect 容器名或容器id</code>  查看容器细节（WorkingDir工作目录、ip地址）</p>\n<p><code>exit</code>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t      退出容器</p>\n<p><code>docker cp /etc/hosts 容器名或容器id:/opt</code>\t 拷贝宿主机的hosts文件到容器的/opt目录下</p>\n<p><code>docker cp 容器名或容器id:/opt/a.sh /tmp</code>\t\t拷贝容器的a.sh文件到宿主机的/tmp路径下</p>\n<p><code>docker logs 容器名</code>          查看容器日志</p>\n<p><code>docker logs -f 容器名</code>   实时查看容器日志</p>\n<p><code>docker commit 容器名或容器id 镜像名:版本</code> 将当前容器打包成一个新的镜像</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 8.数据卷</h2>\n<h3> 基础</h3>\n<p>作用：同来实现<code>容器中数据</code> 和 <code>宿主机中数据</code>进行<mark>文件或目录</mark>的**映射（同步）**的；<strong>持久化容器数据到宿主机上</strong></p>\n<p>注意：数据卷使用必须在<strong>容器首次启动时设置</strong></p>\n<p>应用场景：容器中的服务需要存储数据的，就要使用到数据卷；这样即使docker容器被删除了，那么它里面的<strong>数据还存在于数据卷</strong>中，这样再启动一个容器将数据卷中的数据映射到新容器中，数据也就恢复了。推荐生产一定要使用数据卷！</p>\n<blockquote>\n<p>1.使用绝对路径设置数据卷</p>\n</blockquote>\n<ul>\n<li>\n<p>docker run -v 宿主机绝对路径1:容器内路径1  -v <code>宿主机绝对路径2:容器内路径2</code>  镜像</p>\n<p>注意: 这种方式会<strong>将容器路径的原始内容全部清空,始终以宿主机路径为主</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>ro选项 只能用在容器的路径后面，ro表示宿主机的目录改变只能影响到容器，容器不能影响到宿主机</p>\n</li>\n</ul>\n<blockquote>\n<p>2.使用别名创建</p>\n</blockquote>\n<ul>\n<li>注意：这种创建数据卷的方式会<strong>保留原有容器路径下的内容</strong></li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>aaaa是docker在宿主机自建的目录，docker自己会创建这个别名并维护</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h3> 高级</h3>\n<p>别名代表一个docker自身维护的数据卷</p>\n<p><code>docker volume ls</code>：查看所有docker维护数据卷</p>\n<p><code>docker inspect 数据卷别名</code> 查看数据卷详细内容</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>docker volume rm 数据卷别名</code>删除一个数据卷</p>\n<p><code>docker volume create 数据卷别名</code>创建一个数据卷</p>\n<h2> 9.网络配置</h2>\n<h3> 默认网桥</h3>\n<p>容器间通信：容器之间不可避免存在网络相互通信。</p>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> <strong>虚拟网桥</strong>，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201502692.png\" alt=\"image-20221228145803100\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>通过宿主机<code>ip a</code>可以查看到</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201502704.png\" alt=\"image-20221228145136509\" loading=\"lazy\"></p>\n</li>\n</ul>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\" target=\"_blank\" rel=\"noopener noreferrer\">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络（<strong>不需要做额外的处理</strong>）</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201502019.png\" alt=\"image-20221228144427212\" loading=\"lazy\"></p>\n<blockquote>\n<p>总结</p>\n</blockquote>\n<p>1.默认docker在创建容器时将所有容器都连接到docker0网桥上，默认在docker0网桥的容器都可以使用<strong>容器内ip地址</strong>进行通信</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2.默认docker创建容器时将所有容器都连接到docker0网桥上，默认在docker0网桥的容器都可以使用<strong>容器名称作为容器ip</strong>进行通信，但是注意：使用容器名称<strong>必须自定义网桥</strong>不能使用默认dockero</p>\n<hr>\n<h3> 自定义网桥</h3>\n<p>1.docker网桥类型，有三种bridge、host、none</p>\n<ul>\n<li>允许连接到同一网桥网络的容器进行通信，同时提供与未连接到该网桥网络的容器的隔离</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2.查看网络 <code>docker network ls</code></p>\n<p>3.查看某网络细节<code>docker network inspect 网络名称</code></p>\n<ul>\n<li>在自定义网络创建容器前</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>在自定义网络创建容器两个容器后：</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>4.删除一个网络</p>\n<p><code>docker network rm 网络名称</code></p>\n<p><code>docker network prune</code> 删除所有未被用到网络</p>\n<p><strong>5.创建自定义网桥</strong></p>\n<p><code>docker network create 网络名称</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>自定义网桥后就可以通过名称来访问容器</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>6.运行多个容器在指定网络中</strong></p>\n<p>a.启动容器时明确指定容器使用那个网络</p>\n<p><code>docker run -d --network 网络名称</code></p>\n<p>b.启动之后容器加入到某个网络中</p>\n<p><code>docker network connect 网络名 容器id(name)</code></p>\n<h2> 10.Dockerfile</h2>\n<blockquote>\n<p>注意D大写f小写，是Dockerfile而不是dockerFile</p>\n</blockquote>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201502003.png\" alt=\"image-20230108154217367\" loading=\"lazy\"></p>\n<p>1.概念：Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。</p>\n<p>2.作用：<strong>用来构建docker镜像的构建文件</strong>。</p>\n<p>3.如何构建自己的镜像</p>\n<p>​\ta.在指定位置创建Dockerfile文件。编写dockerfile相关语法</p>\n<p>​\tb.通过Dockerfile构建镜像。<code>docker build -t aa:1.0 . </code>(.用来指定Dockerfile文件所在位置)</p>\n<h3> 构建镜像流程</h3>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201502335.png\" alt=\"image-20230108154417283\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>执行build命令时，会将<strong>Dockerfile的上下文</strong>目录中<code>所有文件</code>都发给Server引擎；也可以写<code>.dockerIgnore</code>文件去选择发送哪些文件；</p>\n</li>\n<li>\n<p>Dockerfile要求一行只有存在一条完整命令；</p>\n</li>\n<li>\n<p>Server引擎会根据第一行命令，构建出一个临时镜像；第二天指令，在第一个临时镜像再构建一个临时镜像，最终生成一个最终镜像（这个镜像Id就是通过docker images看到的）；</p>\n</li>\n<li>\n<p>Docker使用缓存存下这些临时镜像，方便后续相同命令直接获取；</p>\n</li>\n</ul>\n<h3> Dockerfile指令</h3>\n<p>官方说明:<a href=\"https://docs.docker.com/engine/reference/builder/\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.docker.com/engine/reference/builder/</a></p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><table>\n<thead>\n<tr>\n<th>保留字</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>FROM</strong></td>\n<td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td>\n</tr>\n<tr>\n<td>MAINTAINER</td>\n<td>镜像维护者的姓名和邮箱地址</td>\n</tr>\n<tr>\n<td><strong>RUN</strong></td>\n<td><strong>构建镜像时需要运行的指令</strong></td>\n</tr>\n<tr>\n<td><strong>EXPOSE</strong></td>\n<td><strong>当前容器对外暴露出的端口号</strong></td>\n</tr>\n<tr>\n<td><strong>WORKDIR</strong></td>\n<td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td>\n</tr>\n<tr>\n<td><strong>ENV</strong></td>\n<td><strong>用来在构建镜像过程中设置环境变量</strong></td>\n</tr>\n<tr>\n<td><strong>ADD</strong></td>\n<td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td>\n</tr>\n<tr>\n<td><strong>COPY</strong></td>\n<td><strong>类似于ADD，拷贝文件和目录到镜像中<br>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td>\n</tr>\n<tr>\n<td><strong>VOLUME</strong></td>\n<td><strong>容器数据卷，用于数据保存和持久化工作</strong></td>\n</tr>\n<tr>\n<td><strong>CMD</strong></td>\n<td><strong>指定一个容器启动时要运行的命令<br>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td>\n</tr>\n<tr>\n<td><strong>ENTRYPOINT</strong></td>\n<td><strong>指定一个容器启动时要运行的命令<br>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td>\n</tr>\n</tbody>\n</table>\n<h3> 构建过程</h3>\n<p><code>docker build -t 镜像名称:Tag .</code>  构建镜像，指定名称和Tag</p>\n<h4> 1.创建Dockerfile文件</h4>\n<p>建议创建一个单独文件夹，创建一个<code>Dockerfile</code>文件，去编写指令</p>\n<p><code>mkdir docker</code></p>\n<p><code>cd docker</code></p>\n<p><code>mv Dockerfile docker/</code></p>\n<p><code>vim Dockerfile</code></p>\n<p>添加指令<code>FROM centos:latest</code>，保存退出</p>\n<h4> 2.构建自己的镜像</h4>\n<p><code>docker build -t ruybos:01 .</code>  注意一定要加上最后的.；</p>\n<p>可以看到，因为Dockerfile中只有一个FROM指令，所以它的最终镜像id和centos一样；</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.给镜像安装vim</h4>\n<p>RUN命令 在上一步的镜像上执行一些操作</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>添加指令<code>RUN yum install -y vim</code></p>\n<p>构建镜像<code>docker build -t ruybos:02 .</code></p>\n<p>创建容器，验证</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.Expose</h4>\n<p>注意：<strong>仅仅是声明</strong></p>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n<div class=\"language-docker line-numbers-mode\" data-ext=\"docker\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.WORKDIR</h4>\n<p>用来指定构建的镜像在运行为容器时，进入的目录</p>\n<div class=\"language-docker line-numbers-mode\" data-ext=\"docker\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.ADD、COPY</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<div class=\"language-docker line-numbers-mode\" data-ext=\"docker\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<ul>\n<li>ADD比COPY多的功能是 可以通过<code>ADD url</code>自动下载文件，添加到镜像的<code>WORKDIR</code>目录下</li>\n</ul>\n<h4> 7.ENV</h4>\n<p>设置环境变量，方便维护</p>\n<ul>\n<li>指定BASE_PATH常量</li>\n<li>倒数第二个 <code>WORKDIR tomcat-9.0.48</code> 是进入tomcat-9.04.48目录，创建了aa.txt文件</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201502584.png\" alt=\"image-20230116151253167\" loading=\"lazy\"></p>\n<h4> 8.VOLUME</h4>\n<p>注意：<strong>仅仅是声明</strong></p>\n<p>定义容器运行时可以挂在到宿主机的目录</p>\n<h4> 9.CMD和ENTRYPOINT</h4>\n<p>语法1：直接命令方式</p>\n<p><code>java -jar ems.jar</code></p>\n<p>语法2：json数组方式 <strong>推荐</strong></p>\n",
      "image": "https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201501619.webp",
      "date_published": "2023-03-27T00:00:00.000Z",
      "date_modified": "2023-03-27T01:05:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "docker && k8s"
      ]
    },
    {
      "title": "springcloud",
      "url": "https://mister-hope.github.io/tech/spring/SpringCloud.html",
      "id": "https://mister-hope.github.io/tech/spring/SpringCloud.html",
      "summary": "什么是微服务 官网: https://www.martinfowler.com/articles/microservices.html In short, the microservice architectural(架构) style is an approach to developing a single application as a suite(系列) of small services, each running in its own process(进程) and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business(业务) capabilities(单元) and independently(独立) deployable(部署) by fully automated deployment machinery. There is a bare(基于) minimum of centralized(集中) management(管理) of these services, which may be written in different programming languages and use different data storage technologies. -----[摘自官网]",
      "content_html": "<h2> 什么是微服务</h2>\n<ul>\n<li>官网: <a href=\"https://www.martinfowler.com/articles/microservices.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.martinfowler.com/articles/microservices.html</a></li>\n</ul>\n<p>In short, the microservice architectural(架构) style is an approach to developing a single application as <code>a suite(系列) of small services</code>, each <code>running in its own process(进程)</code> and communicating with lightweight mechanisms, often an HTTP resource API. These services are <code>built around business(业务) capabilities(单元)</code> and <code>independently(独立) deployable(部署)</code> by fully automated deployment machinery. <code>There is a bare(基于) minimum of centralized(集中) management(管理) of these services</code>, which may be written in different programming languages and use different data storage technologies.                        -----[摘自官网]</p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>官方定义:<strong>微服务就是由一系列围绕自己业务开发的微小服务构成,他们独立部署运行在自己的进程里,基于分布式的管理</strong></li>\n<li>通俗定义:<strong>微服务是一种架构，这种架构是将单个的整体应用程序分割成更小的项目关联的独立的服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现。这些独立的微服务不需要部署在同一个虚拟机，同一个系统和同一个应用服务器中。</strong></li>\n</ul>\n<hr>\n<h2> 为什么是微服务?</h2>\n<h3> 单体应用</h3>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201515958.png\" alt=\"image-20200708224716035\" loading=\"lazy\"></p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 微服务架构应用</h3>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201515962.png\" alt=\"image-20200723155352063\" loading=\"lazy\"></p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 架构的演变</h3>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>dubbo官网:<a href=\"http://dubbo.apache.org/zh-cn/docs/user/preface/background.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://dubbo.apache.org/zh-cn/docs/user/preface/background.html</a></li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201515966.png\" alt=\"image-20200318082336122\" loading=\"lazy\"></p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>好的架构并不是设计出来的,一定是进化来的</strong></p>\n<hr>\n<h2> 微服务的解决方案</h2>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201515979.png\" alt=\"image-20200724143456045\" loading=\"lazy\"></p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 什么是SpringCloud</h2>\n<h3> 官方定义</h3>\n<ul>\n<li>官方网址: <a href=\"https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/html/\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/html/</a></li>\n</ul>\n<p><strong>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems</strong> (e.g. <code>configuration management</code>,<code> service discovery</code>, <code>circuit breakers, intelligent routing, micro-proxy, control bus</code>). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns.  -------[摘自官网]</p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 核心架构及其组件</h3>\n<p>官网地址:<a href=\"https://spring.io/projects/spring-cloud\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/projects/spring-cloud</a></p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><mark>各组件架构图</mark></p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201515983.png\" alt=\"image-20200724161314786\" loading=\"lazy\"></p>\n<h2> 注册中心</h2>\n<p>所谓服务注册中心就是在整个的微服务架构中单独提出一个服务，这个服务<strong>不完成系统的任何的业务功能</strong>，仅仅用来完成对整个微服务系统的<strong>服务注册</strong>和<strong>服务发现</strong>，以及对服务**健康状态的监控（心跳检查）**和管理功能。</p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201601873.png\" alt=\"image-20230320160102818\" loading=\"lazy\"></p>\n<h2> pom.xml</h2>\n<p>parent</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Eureka 注册中心</h2>\n<h3> 用法-Server端</h3>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 自我保护机制</h4>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201525482.png\" alt=\"image-20230320152556436\" loading=\"lazy\"></p>\n<p><strong>周期是15 分钟，server要判断15分钟之内是否低于 85%</strong></p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 用法-Client端</h3>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Consul 注册中心</h2>\n<h3> 概念</h3>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 用法-Server端</h3>\n<p>使用Consul可以直接安装启动，<strong>不需要手动开发这个注册中心</strong>，这一点区别于Eureka</p>\n<p>consul默认服务端口是<strong>8500</strong></p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 用法-Client端</h3>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Ribbon 负载均衡</h2>\n<blockquote>\n<p>精品文章：<a href=\"http://c.biancheng.net/springcloud/ribbon.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://c.biancheng.net/springcloud/ribbon.html</a></p>\n</blockquote>\n<p>在springcloud中服务间调用方式主要是使用 <code>http restful</code>方式进行服务间调用；</p>\n<p>目前主流的负载方案分为以下两种：</p>\n<ul>\n<li>\n<p><strong>集中式</strong>负载均衡，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如 F5），也有软件的（比如Nginx）</p>\n</li>\n<li>\n<p><strong>客户端</strong>根据自己的请求情况做负载均衡，Ribbon 就属于客户端自己做负载均衡</p>\n</li>\n</ul>\n<h3> 概念</h3>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过Load Balancer获取到服务提供的所有机器实例，Ribbon会自动基于某种规则(轮询，随机)去调用这些服务</p>\n<h3> 依赖</h3>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 配置</h3>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 用法</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 负载均衡策略</h3>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> OpenFeign 服务调用</h2>\n<h3> 概念</h3>\n<p>OpenFeign 全称 Spring Cloud OpenFeign，它是 Spring 官方推出的一种<strong>声明式服务调用与负载均衡组件</strong>，它的出现就是为了替代进入停更维护状态的 Feign</p>\n<p>Feign 对<strong>Ribbon进行了集成</strong>，它在 <strong>RestTemplate 的基础上做了进一步的封装</strong>。通过 Feign，我们只需要声明一个接口并通过注解进行简单的配置（类似于 Dao 接口上面的 Mapper 注解一样）即可实现对 HTTP 接口的绑定。</p>\n<p>通过 Feign，我们可以像调用本地方法一样来调用远程服务，而完全感觉不到这是在进行远程调用。</p>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 配置</h3>\n<p>超时控制和日志级别</p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 注解</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 用法</h3>\n<p>在编写服务绑定接口时，需要注意以下 2 点：</p>\n<ul>\n<li>在 @FeignClient 注解中，value 属性的取值为：<strong>服务提供者的服务名</strong>，即服务提供者配置文件（application.yml）中 <a href=\"http://spring.application.name\" target=\"_blank\" rel=\"noopener noreferrer\">spring.application.name</a> 的取值。</li>\n<li>接口中定义的每个方法都与<strong>服务提供者中 Controller 定义的服务方法</strong>对应。</li>\n</ul>\n<p>Spring Cloud 应用在启动时，<code>OpenFeign 会扫描标有 @FeignClient 注解的接口生成代理，并注人到 Spring 容器中</code>。</p>\n<hr>\n<ol>\n<li>创建一个客户端调用接口（前提是PRODUCTS有相应的controller接口）</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>使用feignClient客户端对象调用服务</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Hystrix 服务熔断、服务降级</h2>\n<blockquote>\n<p>精品文章：<a href=\"http://c.biancheng.net/springcloud/hystrix.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://c.biancheng.net/springcloud/hystrix.html</a></p>\n</blockquote>\n<h3> 概念</h3>\n<p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障(服务雪崩现象)，提高分布式系统的弹性。</p>\n<p>Spring Cloud Hystrix 是基于 Netflix 公司的开源组件 Hystrix 实现的，它提供了熔断器功能，能够有效地阻止分布式微服务系统中出现联动故障，以提高微服务系统的弹性。Spring Cloud Hystrix 具有服务降级、服务熔断、线程隔离、请求缓存、请求合并以及实时故障监控等强大功能。</p>\n<blockquote>\n<p>Hystrix [hɪst'rɪks]，中文含义是豪猪，豪猪的背上长满了棘刺，使它拥有了强大的自我保护能力。而 Spring Cloud Hystrix 作为一个服务容错与保护组件，也可以让服务拥有自我保护的能力，因此也有人将其戏称为“豪猪哥”。</p>\n</blockquote>\n<p>在微服务系统中，Hystrix 能够帮助我们实现以下目标：</p>\n<ul>\n<li><strong>保护线程资源</strong>：防止单个服务的故障耗尽系统中的所有线程资源。</li>\n<li><strong>快速失败机制</strong>：当某个服务发生了故障，不让服务调用方一直等待，而是直接返回请求失败。</li>\n<li><strong>提供降级（FallBack）方案</strong>：在请求失败后，提供一个设计好的降级方案，通常是一个兜底方法，当请求失败后即调用该方法。</li>\n<li><strong>防止故障扩散</strong>：使用熔断机制，防止故障扩散到其他服务。</li>\n<li><strong>监控功能</strong>：提供熔断器故障监控组件 Hystrix Dashboard，随时监控熔断器的状态。</li>\n</ul>\n<h3> 服务雪崩-服务级联故障</h3>\n<p>在微服务之间进行服务调用是由于某一个服务故障，导致级联服务故障的现象，称为雪崩效应。雪崩效应描述的是提供方不可用，导致消费方不可用并将不可用逐渐放大的过程。</p>\n<p>如图存在如下调用链路:</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201731187.png\" alt=\"image-20230320173125136\" loading=\"lazy\"></p>\n<p>而此时，Service A的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求。此时，如果Service C因为抗不住请求，变得不可用。那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用。紧接着，Service A也会不可用，这一过程如下图所示</p>\n<p><strong>每个请求都是tomcat启动的线程，当服务器C不断有请求线程过来却没有被释放，线程资源占用越来越多，服务就会不可用</strong></p>\n<h3> 服务熔断-自我熔断</h3>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>熔断机制：每个微服务都<strong>引入自己服务的监控器</strong>Hystrix，<strong>监控到异常后会返回一个fallBack</strong></p>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 用法</h4>\n<p>使用HystrixCommand注解实现断路</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 断路器打开条件</h4>\n<p>当满足Hystrix的条件后，熔断器会打开（请求走到熔断器条件），但是一会后熔断器又会关闭（请求恢复正常），说明它状态的打开关闭有条件：</p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201802972.png\" alt=\"image-20230320180230891\" loading=\"lazy\"></p>\n<h3> 服务降级</h3>\n<blockquote>\n<p>精品文章：<a href=\"https://www.jianshu.com/p/fcb8b26b12a5\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/fcb8b26b12a5</a></p>\n</blockquote>\n<p>服务降级：在服务器压力陡增的情况下，利用有限资源，根据当前业务情况，关闭某些服务接口或者页面，以此释放服务器资源以保证核心任务的正常运行。</p>\n<p>降级：服务分优先级，牺牲非核心服务（不可用），导致整体的服务下降，保证核心服务稳定；</p>\n<p>流量控制本质上是减小访问量，而服务处理能力不变；而服务降级本质上是<strong>降低了部分服务的处理能力，增强另一部分服务处理能力，而访问量不变</strong></p>\n<h4> 配置</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<p>在openfeign客户端中加如Hystrix</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>处理类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 异同点总结</h3>\n<ul>\n<li>\n<p>服务熔断一般是<strong>某个服务</strong>（下游服务）故障引起，而服务降级一般是从<strong>整体负荷</strong>考虑</p>\n</li>\n<li>\n<p>熔断其实是一个<strong>框架级</strong>的处理，每个微服务都需要（无层级之分），而降级一般需要<strong>对业务有层级之分</strong>（比如降级一般是从最外围服务开始）</p>\n</li>\n</ul>\n<h2> Gateway 服务网关</h2>\n<h3> 概念</h3>\n<p>网关统一服务入口，对微服务的一切请求进行路由转发，并提供横切关注点</p>\n<p>客户端向Spring Cloud Gateway发送请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关Web处理程序。此处理程序通过特定于请求的过滤器链运行请求。用虚线分隔过滤器的原因是<strong>过滤器可以在发送代理请求之前和之后运行逻辑</strong>。执行所有预过滤逻辑。然后发出代理请求。发出代理请求后，运行post filter逻辑</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201846934.png\" alt=\"spring_cloud_gateway_diagram\" loading=\"lazy\"></p>\n<h3> 作用</h3>\n<ol>\n<li>统一所有微服务的全局入口</li>\n<li><strong>路由转发</strong>（接收一切外界请求，转发到后端的微服务上去） + <strong>过滤器</strong>（权限控制，流量监控，限流）</li>\n<li>实现负载均衡</li>\n</ol>\n<h3> 用法</h3>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 常见路由predicate  （断言、验证）</h4>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 常见过滤器</h4>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Config 配置中心</h2>\n<blockquote>\n<p>精品文章：<a href=\"http://c.biancheng.net/springcloud/config.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://c.biancheng.net/springcloud/config.html</a></p>\n</blockquote>\n<h3> 概念</h3>\n<p>微服务系统中服务的统一管理组件</p>\n<p>类似Eureka一样，Server端集中管理配置文件，Client端拉取使用配置文件</p>\n<ul>\n<li>\n<p>服务注册中心：统一管理微服务信息</p>\n</li>\n<li>\n<p>统一配置中心：统一管理微服务的配置信息</p>\n</li>\n</ul>\n<p>Spring Cloud Config 包含以下两个部分：</p>\n<ul>\n<li>Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来<strong>连接配置仓库并为客户端提供获取配置信息</strong>、加密信息和解密信息的访问<strong>接口</strong>。</li>\n<li>Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并<strong>从 Config Sever 中获取和加载配置信息</strong></li>\n</ul>\n<hr>\n<p>微服务启动时会从Server端（即配置中心）拉取配置文件，为了提高config的高可用，当Server端集群部署时，如何实现一个Server节点的修改同步到其它Server节点呢？所以Spring和奈飞设计Config组件作为临时的配置文件中转，而不是作为终端提供者。</p>\n<p>当配置文件经常修改，就需要去进行版本管理，自然想到Git，借助其git仓库管理配置文件。那么如何连接git仓库和每一个微服务呢？config配置中心就可以通过uri拉取git仓库到本地（即自身Server端），其它微服务作为Config Client端进行访问</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303151018819.png\" alt=\"image-20230315101818765\" loading=\"lazy\"></p>\n<p><strong>当git仓库配置发生变化，Config Server检测到后，就从git仓库同步拉取最新配置文件并缓存一份到本地</strong>（安全考虑git仓库可能宕机，所以缓存一份）；其它微服务重新启动时读取到的就是最新的配置文件了</p>\n<h3> 作用</h3>\n<p>将配置统一管理，在日后大规模集群部署服务应用时相同的服务配置一致，日后只需要统一修改配置全部同步，不需要一个一个服务手动维护</p>\n<h3> git仓库</h3>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303151514206.png\" alt=\"image-20230315151427158\" loading=\"lazy\"></p>\n<h3> 用法-Server端</h3>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 使用</h4>\n<p>Spring Cloud Config 规定了一套配置文件访问规则，如下表</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303210930865.png\" alt=\"image-20230321093053816\" loading=\"lazy\"></p>\n<p>可以通过访问localhost:7999/configclient-dev.yml来查看配置文件；</p>\n<p>同时后台会有缓存配置文件的本地目录路径；</p>\n<h3> 用法-Client端</h3>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<p>为了能够提前从Server端拉取到配置文件，再以拉取到的配置加载启动config client。因此，需要将config client的配置写到<mark>bootstrap.yml</mark>中</p>\n<blockquote>\n<p>注意：bootstrap中一定要指明与注册中心有关的配置。如该client服务名称、注册中心地址、端口</p>\n</blockquote>\n<p><mark>bootstrap.yml</mark>，注意这里，可不是application.yml哦</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h4> 用法</h4>\n<p>使用client的controller测试，读取到的值应该是bootstrap.yml中指定的文件中的name值</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意点：client同时也会加载公共配置中的值，比如在configclient中指定了port为8000，后续在bootstrap.yml和虚拟机选项中再指定port不会生效</p>\n<hr>\n<p>需要注意的是，当配置更新后，config client端如果不重启是</p>\n<ul>\n<li>配置更新后，Spring Cloud Config 服务端（Server）可以直接从 Git 仓库中获取最新的配置。</li>\n<li>除非重启 Spring Cloud Config 客户端（Client），否则无法通过 Spring Cloud Config 服务端获取最新的配置信息。</li>\n</ul>\n<h3> 手动配置刷新</h3>\n<h4> 依赖</h4>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<p>需要刷新代码的类中加入刷新配置的注解</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> <strong>手动调用</strong></h4>\n<p>发送一个 POST 请求刷新Config客户端，通知客户端配置文件已经修改，需要重新拉去配置</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><hr>\n<p>问题接踵而至：</p>\n<p>只要配置仓库中的配置发生改变，就需要我们<strong>挨个向 Config 客户端手动发送 POST 请求</strong>，通知它们重新拉取配置。</p>\n<p>显然不科学，辣么多微服务，我疯了吗？</p>\n<h2> Bus 消息总线</h2>\n<h3> 概念</h3>\n<p><code>Spring Cloud Bus</code> 又被称为消息总线，它能够通过轻量级的消息代理（例如 RabbitMQ、Kafka 等）将微服务架构中的各个服务连接起来，实现广播状态更改、事件推送等功能，还可以实现微服务之间的通信功能。</p>\n<p>bus称之为springcloud中消息总线，主要用来在微服务系统中<strong>实现远端配置更新时通过广播形式通知所有客户端刷新配置信息</strong>，避免手动重启服务的工作</p>\n<h3> 动态配置刷新</h3>\n<p>Spring Cloud Config  +  Spring Cloud Bus 实现 一次通知，处处生效</p>\n<p>当 Git 仓库中的配置发生了改变，我们只需要向某一个服务（既可以是 Config 服务端，也可以是 Config 客户端）发送一个 POST 请求，Spring Cloud Bus 就可以通过消息代理通知其他服务重新拉取最新配置，以实现配置的动态刷新。</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303211120116.png\" alt=\"101942GY-11\" loading=\"lazy\"></p>\n<p>​\t根据图上 ，利用 Spring Cloud Bus 实现配置的动态刷新需要以下步骤:</p>\n<ol>\n<li>当 Git 仓库中的配置发生改变后，运维人员向 Config 服务端发送一个 POST 请求，请求路径为“/actuator/refresh”。</li>\n<li>Config 服务端接收到请求后，会将该请求转发给服务总线 Spring Cloud Bus。</li>\n<li>Spring Cloud Bus 接到消息后，会通知给所有 Config 客户端。</li>\n<li>Config 客户端接收到通知，请求 Config 服务端拉取最新配置。</li>\n<li>所有 Config 客户端都获取到最新的配置。</li>\n</ol>\n<h3> 安装rabbitmq</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 用法</h3>\n<h4> 依赖</h4>\n<p>server和client端都添加</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置</h4>\n<p>server和client端都添加</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 注解</h4>\n<p>一定要加这个注解<code>@RefreshScope</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 用法</h4>\n<p>手动触发一下</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "image": "https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303201515958.png",
      "date_published": "2023-03-27T00:00:00.000Z",
      "date_modified": "2023-03-27T01:05:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "关于博客",
      "url": "https://mister-hope.github.io/about_me/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2.html",
      "id": "https://mister-hope.github.io/about_me/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2.html",
      "summary": "写在前面 本博客依赖vuepress-theme-hope主题模板进行搭建，依照官方教程做了些自定义的配置，大致符合自己简洁、清晰的审美理念，就直接上线了。此文档更多的是整体搭建和详细部署的说明，对自定义配置各位参照文档，一两个小时也就搞定了~ 助力每一个想要搭建自己博客的少男少女，愿你少踩点非必要的坑~ 博客相关内容持续集成中，欢迎关注交流！！ 博客搭建 官网有小白教程可以大致参考，多余的不再重复~~",
      "content_html": "<h2> 写在前面</h2>\n<p>本博客依赖<code>vuepress-theme-hope</code>主题模板进行搭建，依照官方教程做了些自定义的配置，大致符合自己简洁、清晰的审美理念，就直接上线了。此文档更多的是整体搭建和详细部署的说明，对自定义配置各位参照文档，一两个小时也就搞定了~</p>\n<p>助力每一个想要搭建自己博客的少男少女，愿你少踩点非必要的坑~</p>\n<p>博客相关内容持续集成中，欢迎关注交流！！</p>\n<h2> 博客搭建</h2>\n<p>官网有<a href=\"https://vuepress-theme-hope.gitee.io/v2/zh/cookbook/tutorial/\" target=\"_blank\" rel=\"noopener noreferrer\">小白教程</a>可以大致参考，多余的不再重复~~</p>\n<h3> 1.运行环境</h3>\n<p>idea + Node.js + pnpm</p>\n<ul>\n<li>\n<p>idea：选择它作为开发工具只有一个原因，那就是习惯了~~官方推荐vscode会有更多的语法提示，但不会使用的配置还是要自己去读文档，提示作用不大，而且idea也有一些提示的；</p>\n</li>\n<li>\n<p>node.js：版本选择的是<code>v16.16.0</code>，大于等于该版本应该均可；</p>\n</li>\n<li>\n<p>pnpm：版本选择的是<code>7.28.0</code>，推荐用它管理项目，比npm速度快、节省空间；</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h3> 2.创建项目</h3>\n<p>找到本机要存放项目的位置，创建文件夹（最好英文），直接cmd在终端输入</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接着一路选择，记得选择<code>pnpm</code>，然后自动部署文档输入<code>y</code>（后面会用到）</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549257.png\" alt=\"image-20230311133146598\" loading=\"lazy\"></p>\n<p>安装好依赖后，会提示输入y查看博客网址</p>\n<ul>\n<li>\n<p>意外情况：输入y出现报错，这个极有可能是vuepress-theme-hope的版本问题，解决方式就是指定该项目的<a href=\"https://github.com/vuepress-theme-hope/vuepress-theme-hope/releases\" target=\"_blank\" rel=\"noopener noreferrer\">版本号</a></p>\n<p>选择github中最新的版本或之前稳定的某版本，再次尝试</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h3> 3.启动项目</h3>\n<p>进入项目终端下输入<code>pnpm docs:dev</code></p>\n<ul>\n<li>如果不出意外，就可以在本机8080端口访问了，当然你也可以修改端口号，在package.json文件修改命令</li>\n</ul>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 博客部署</h2>\n<p>请注意：下面要写的是整个博客的<code>自动部署</code>，并非一次简单的手动部署，所以按需食用</p>\n<h3> step1.上传项目</h3>\n<ul>\n<li>\n<p>github新建仓库，命名要为<code>用户名.github.io</code>，如我的github用户名为ru12321，那么此次新仓库命名为<code>ru12321.github.io</code>，仓库地址如图获取</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549427.png\" alt=\"image-20230311135650669\" loading=\"lazy\"></p>\n</li>\n<li>\n<p><a href=\"http://xn--deploy-9v7iw71aui2c7ho8gxslxr3em80e9yxa.sh\" target=\"_blank\" rel=\"noopener noreferrer\">项目中添加部署脚本deploy.sh</a></p>\n<p>脚本作用：构建项目、将dist下的所有文件由本地的master分支提交到远端仓库<code>ru12321.github.io</code>的<code>gh-pages分支</code></p>\n<p>你要做的：修改仓库地址为自己的即可，远端分支gh-pages命名不要改！</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>执行deploy.sh脚本，进入到脚本位置，右键使用git打开</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549114.png\" alt=\"image-20230311135217147\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>执行脚本<code>sh deploy.sh</code>，上传项目打包文件到远端github.io仓库</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549446.png\" alt=\"image-20230311135303902\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>上传完成后，github pages模块就会触发部署，自动生成你的网站</p>\n<p>如图，去仓库的对应位置，就可以通过这个域名访问自己的网站了</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549896.png\" alt=\"image-20230311135904991\" loading=\"lazy\"></p>\n<p>总结，以上通过deploy.sh脚本实现了<code>项目的构建、上传构建后文件到远端github仓库gh-pages分支、触发pages构建网站</code>，博客网站到此就可以通过<code>https://用户名.github.io</code>域名访问了。但是想想以后你每次修改了博客内容，都要手动去执行下deploy.sh脚本更新你的网站，是不是有点麻烦呢？所以有了接下来自动部署的步骤</p>\n<h3> step2 项目上传</h3>\n<p>为了方便使用github管理项目，及更好的利用github的actions机制，需要上传整个项目到远端<code>用户名.github.io</code>的master主分支上。这样做的目的是，之后每次本地修改了博客内容，通过push到github远端，都会进行后续一系列的自动更新网站，实现自动部署的效果~~</p>\n<ul>\n<li>\n<p>push整个项目内容到远端的master分支上，会git的应该都懂吧。</p>\n<p>中间可能需要登录下github、输入下远端仓库的地址~</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549359.png\" alt=\"image-20230311141326887\" loading=\"lazy\"></p>\n<p>至此，远端仓库有了两个分支</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549945.png\" alt=\"image-20230311141617167\" loading=\"lazy\"></p>\n<p>master：管理整个博客项目使用</p>\n<p>gh-pages：存放的是博客构建后的所有文件，用来通过pages模块生成博客网站</p>\n<h3> step3.修改workflows脚本</h3>\n<p>说明一下：本质就是通过github的actions模块，自动监测项目master分支的变动，然后执行actions的workflows的脚本，依然是<code>项目构建、自动更新代码文件到gh-pages分支上、自动触发pages构建网站</code>，所以重点就是workflows工作流的脚本的编写和相应的配置了</p>\n<p>不出意外的话，项目本身会有<code>.github/workflows/deplooy-docs.yml</code>这个文件，它就是我们需要的脚本！</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上需要修改和注意的地方有三个，其它地方可以对比下，应该不需要改动</p>\n<ol>\n<li>第7行的分支名称：就是我们step2上传的远端分支名称，如master</li>\n<li>第16行<code>fetch-depth: 0</code> 检测分支用的</li>\n<li>第40行 先这样写，接下来说明这一行token的配置</li>\n</ol>\n<h3> step4.生成token</h3>\n<p>上面的token是为了在触发actions自动部署时，action<strong>有权限去切换到gh-pages分支并更新其内容</strong>，所以是必要的！</p>\n<h4> 配置1  生成token</h4>\n<p>点击github右上角头像--<code>settings</code>--<code>developer settings</code>--<code>personal access tokens</code>--<code>token(classic)</code>--<code>generate new token</code>--<code>generate new token(classic)</code></p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549230.png\" alt=\"image-20230311142430423\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>输入密码弹出页面</p>\n<p>输入Note名称为<code>ACCESS_TOKEN</code>  对应上面workflows脚本的那个值</p>\n<p>设定token到期时间、</p>\n<p>勾选token作用范围 repo即可</p>\n</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549027.png\" alt=\"image-20230311142714721\" loading=\"lazy\"></p>\n<ul>\n<li>点击<code>generate token</code> 生成秘钥</li>\n<li>保存复制一串数字+字母组合，如<code>ghp_vzoGj02I0dqwueykhflwZv6Cq4r05q4aN</code>后面会用到</li>\n</ul>\n<h4> 配置2 在仓库配置</h4>\n<ul>\n<li>如图，新建一个secret，命名为<code>ACCESS_TOKEN</code>，值为上面的一串神秘组合</li>\n</ul>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549209.png\" alt=\"image-20230311143235520\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>操作完后就会生成一个secret</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549028.png\" alt=\"image-20230311143502963\" loading=\"lazy\"></p>\n</li>\n</ul>\n<h3> step5.额外配置</h3>\n<p>仓库的settings--<code>Actions</code>--<code>General</code></p>\n<p>如图，修改两个选项为workflows增加操作仓库的权限，修改完记得分部点下save</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549274.png\" alt=\"image-20230311143938914\" loading=\"lazy\"></p>\n<hr>\n<hr>\n<hr>\n<h3> step6.测试一下</h3>\n<p>至此，完成了博客的自动部署配置，可以本地修改某个md文件内容，上传到远端master分支，看看有没有自动出发pages自动更新网站内容呢？actions触发成功会显示为绿色，失败也会有相应的日志可以查看。</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549685.png\" alt=\"image-20230311144241070\" loading=\"lazy\"></p>\n<h2> 写在最后</h2>\n<p>初次尝试搭建博客，过程中有其它问题也欢迎交流，评论（留下邮箱）即可~</p>\n",
      "image": "https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171549257.png",
      "date_published": "2023-03-11T00:00:00.000Z",
      "date_modified": "2023-03-19T10:32:40.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "我"
      ]
    },
    {
      "title": "frontmatter说明",
      "url": "https://mister-hope.github.io/example.html",
      "id": "https://mister-hope.github.io/example.html",
      "summary": "测试页面，用来记录一些页面配置 index: false 不展示在侧边栏，不收集到children中 comment: false 不显示评论 article: false 该md不展示在博客首页的文章列表",
      "content_html": "<p>测试页面，用来记录一些页面配置</p>\n<p>index: false  不展示在侧边栏，不收集到children中\ncomment: false  不显示评论\narticle: false 该md不展示在博客首页的文章列表</p>\n",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-03-27T01:05:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "计算机"
      ]
    },
    {
      "title": "who am i？",
      "url": "https://mister-hope.github.io/about_me/",
      "id": "https://mister-hope.github.io/about_me/",
      "summary": "info标题 我是info内容 一个平平无奇的碳基生物",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">info标题</p>\n<p>我是info内容</p>\n</div>\n<p>一个平平无奇的碳基生物</p>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-10T10:18:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": []
    },
    {
      "title": "我的爱好",
      "url": "https://mister-hope.github.io/about_me/%E6%88%91%E7%9A%84%E7%88%B1%E5%A5%BD.html",
      "id": "https://mister-hope.github.io/about_me/%E6%88%91%E7%9A%84%E7%88%B1%E5%A5%BD.html",
      "summary": "相关信息 就是玩儿 20231012-测试自动部署",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">相关信息</p>\n<p>就是玩儿\n20231012-测试自动部署</p>\n</div>\n",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-10-12T07:15:54.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "我"
      ]
    },
    {
      "title": "书斋",
      "url": "https://mister-hope.github.io/book/",
      "id": "https://mister-hope.github.io/book/",
      "summary": "读过的书~hhhh test2 test3 test4 test5",
      "content_html": "<p>读过的书~hhhh\ntest2\ntest3\ntest4\ntest5</p>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-11T04:39:07.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": []
    },
    {
      "title": "江湖",
      "url": "https://mister-hope.github.io/essay/",
      "id": "https://mister-hope.github.io/essay/",
      "summary": "一点点",
      "content_html": "<p>一点点</p>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-10T10:18:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "生活"
      ]
    },
    {
      "title": "窄门",
      "url": "https://mister-hope.github.io/tech/",
      "id": "https://mister-hope.github.io/tech/",
      "summary": "相关信息 近期正在学习的技术点和遇到的问题",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">相关信息</p>\n<p>近期正在学习的技术点和遇到的问题</p>\n</div>\n",
      "date_published": "2023-03-10T10:18:52.000Z",
      "date_modified": "2023-03-19T10:32:40.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": []
    },
    {
      "title": "jdk8新特性",
      "url": "https://mister-hope.github.io/tech/java/jdk%E6%96%B0%E7%89%B9%E6%80%A7.html",
      "id": "https://mister-hope.github.io/tech/java/jdk%E6%96%B0%E7%89%B9%E6%80%A7.html",
      "summary": "学习资料 https://blog.csdn.net/LXYDSF/article/details/125919046 一、Stream新特性 Stream概念 java.util.stream包 Stream 是Java8 中处理集合的关键抽象概念，它可以对集合执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。 Stream API 提供了一种高效且易于使用的处理数据的方式。 Stream 和Collection 集合的区别：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算。 集合讲的是数据，关注的是数据的存储，与内存打交道 Stream 讲的是计算，关注的是对数据的运算，与CPU打交道 Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream 。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。",
      "content_html": "<p>学习资料 <a href=\"https://blog.csdn.net/LXYDSF/article/details/125919046\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/LXYDSF/article/details/125919046</a></p>\n<h1> 一、Stream新特性</h1>\n<h2> Stream概念</h2>\n<p>java.util.stream包</p>\n<ul>\n<li>\n<p>Stream 是Java8 中<strong>处理集合</strong>的关键抽象概念，它可以对集合执行非常复杂的查找、过滤和映射数据等操作。<strong>使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询</strong>。</p>\n</li>\n<li>\n<p>Stream API 提供了一种高效且易于使用的处理数据的方式。</p>\n<ul>\n<li><strong>Stream 和Collection 集合的区别</strong>：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算。</li>\n</ul>\n</li>\n<li>\n<p><strong><mark>集合讲的是数据，关注的是数据的存储，与内存打交道</mark></strong></p>\n</li>\n<li>\n<p><strong><mark>Stream 讲的是计算，关注的是对数据的运算，与CPU打交道</mark></strong></p>\n</li>\n<li>\n<p>Stream是<mark>数据渠道</mark>，用于操作数据源（集合、数组等）所生成的元素序列。</p>\n<ul>\n<li>Stream 自己不会存储元素。</li>\n<li>Stream 不会改变源对象。相反，他们会<em>返回一个持有结果的新 Stream</em> 。</li>\n<li>Stream 操作是延迟执行的。这意味着他们会等到<em>需要结果的时候才执行</em>。</li>\n</ul>\n</li>\n</ul>\n<h2> Stream操作</h2>\n<h3> 1 操作步骤</h3>\n<ol>\n<li>创建 Stream 一个数据源（如：集合、数组），获取一个</li>\n<li>中间操作（<strong>非必要</strong>） 一个中间操作链，对数据源的数据进行处理</li>\n<li>终止操作 一旦执行 终止操作， 就 执行中间操作链 ，并产生结果 。之后，不会再被使用</li>\n</ol>\n<h3> 2 创建</h3>\n<h4> <strong>2.1 通过集合</strong></h4>\n<p>最常见！ 集合.stream()</p>\n<p>Java8中的 Collection 接口被扩展，提供了两个获取流的方法<code>.stream()</code>，<code>.parallelStream()</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2.2 Arrays.stream()</h4>\n<p>Java8中的 Arrays 的静态方法 <code>Arrays.stream()</code> 可以获取数组流：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>重载形式，能够处理对应基本类型的数组：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2.3 Stream.of()</h4>\n<p>可以调用Stream 类静态方法<code>Stream.of()</code> , 通过显示值创建一个流。它可以接收任意数量的参数。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2.4 无限流</h4>\n<p>可以使用Stream 类静态方法<code>Stream.iterate()</code> 和 <code>Stream.generate()</code>，创建无限流。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3 中间操作</h3>\n<p>多个<strong>中间操作</strong> 可以连接起来形成一个 <strong>流水线</strong> ，除非流水线上触发终止操作，否则 <strong>中间操作不会执行任何的处理</strong> ！而在 <mark><em>终止操作时一次性全部处理</em></mark>，称为“惰性求值” 。</p>\n<h4> 3.1 筛选与切片</h4>\n<ul>\n<li>\n<p><strong>filter(Predicate p)：接收Lambda ，获得满足条件P（断定型接口 返回Boolean值）的元素</strong></p>\n</li>\n<li>\n<p><strong>distinct()：去除重复元素（同一个内存地址的）</strong></p>\n</li>\n<li>\n<p><strong>limit(long maxSize)：截断流，使其元素不超过给定数量</strong></p>\n</li>\n<li>\n<p>skip(long n)：跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与<code>limit(n)</code>互补</p>\n</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.2 映射</h4>\n<ul>\n<li><strong>map(Function f)：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</strong></li>\n<li>mapToDouble(ToDoubleFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。</li>\n<li>mapToInt(ToIntFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。</li>\n<li>mapToLong(ToLongFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。</li>\n<li>flatMap(Function f)：接收一个函数作为参数，将流中的每个值都换成另一个流，<strong>然后把所有流连接成一个流</strong></li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.3 排序</h4>\n<ul>\n<li><strong>sorted()：产生一个新流，其中按自然顺序排序</strong></li>\n<li>sorted(Comparator com)：产生一个新流，其中按比较器顺序排序</li>\n</ul>\n<h3> 4 终止操作</h3>\n<ul>\n<li>\n<p><mark>流不一定需要中间操作，可以直接创建--&gt;终止操作</mark></p>\n</li>\n<li>\n<p>终端操作<strong>会从流的流水线生成结果</strong>。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 。</p>\n</li>\n<li>\n<p>流进行了终止操作后，不能再次使用。</p>\n</li>\n</ul>\n<h4> 4.1 匹配与查找</h4>\n<ul>\n<li>\n<p>allMatch(Predicate p)：检查是否匹配所有元素</p>\n</li>\n<li>\n<p><strong>anyMatch(Predicate p)：检查是否至少匹配一个元素</strong></p>\n</li>\n<li>\n<p>noneMatch(Predicate p)：检查是否没有匹配所有元素</p>\n</li>\n<li>\n<p><strong>findFirst()：返回第一个元素</strong></p>\n</li>\n<li>\n<p>findAny()：返回当前流中的任意元素</p>\n</li>\n<li>\n<p>count()：返回流中元素总数</p>\n</li>\n<li>\n<p>max(Comparator c)：返回流中最大值。参数是比较器，比如Comparator.comparing(String::length)</p>\n</li>\n<li>\n<p>min(Comparator c)：返回流中最小值。</p>\n</li>\n<li>\n<p><strong>forEach(Consumer c)：内部迭代</strong></p>\n</li>\n</ul>\n<h4> 4.2 reduce 归约</h4>\n<p>归约：将一个Stream中的所有元素反复结合起来,得到一个结果</p>\n<p>备注：map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。</p>\n<ul>\n<li>reduce(T iden, BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。返回T</li>\n<li>reduce(BinaryOperator b)：参数是二元函数。可以将流中元素反复结合起来，得到一个值。<mark>返回Optional对象</mark>，</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.3 收集</h4>\n<ul>\n<li>collect(Collector c)：将流转换为<mark>其他形式（如List 、 Set 、Map等）</mark>。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</li>\n</ul>\n<p>Collector接口中方法的实现决定了如何对流执行收集的操作 如收集到 List 、 Set 、Map。</p>\n<p>另外，Collectors 实用类提供了很多<strong>静态方法</strong>，可以方便地创建常见收集器实例</p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171547597.png\" alt=\"image-20230317154719527\" loading=\"lazy\"></p>\n<p><img src=\"https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171547592.png\" alt=\"image-20230317154727522\" loading=\"lazy\"></p>\n<h1> 二、Lambda表达式</h1>\n<p>Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（<mark>将代码像数据一样进行传递</mark>）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>\n<ul>\n<li>好处：避免匿名内部类定义过多，可以让代码简洁紧凑，留下核心的逻辑</li>\n</ul>\n<ul>\n<li>\n<p>Lambda表达式特征</p>\n<ul>\n<li>**可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。</li>\n<li>**可选的参数圆括号：**一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>\n<li>**可选的大括号：**如果主体包含了一个语句，就不需要使用大括号。</li>\n<li>**可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>\n</ul>\n</li>\n<li>\n<p>注意：lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>\n</li>\n</ul>\n<h1> 三、函数式接口</h1>\n<h2> 1 函数式接口概念</h2>\n<ul>\n<li>\n<p>定义：<mark>只包含一个抽象方法的接口</mark></p>\n</li>\n<li>\n<p>使用 <code>@FunctionalInterface</code> 注解<strong>用来测试用</strong>，如果不是函数式接口，那么会报错；</p>\n<ul>\n<li>只要满足函数式接口的定义，<em>这个注解写不写无所谓</em></li>\n</ul>\n</li>\n<li>\n<p>可以通过 <code>Lambda </code>表达式来创建该接口的对象</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>java 不但可以支持 OOP 还可以支持 OOF （面向函数编程），<mark>将函数作为参数，进行传递</mark></p>\n</li>\n<li>\n<p>在 Java8 中， <code>Lambda</code> 表达式就是一个函数式接口的实例</p>\n</li>\n</ul>\n<h2> 2 Java内置的函数式接口</h2>\n<blockquote>\n<p><strong>一定要注意这些函数参数类型什么，返回类型是什么</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>函数式接口</th>\n<th>参数类型</th>\n<th>返回类型</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Consumer&lt;T&gt;</code></td>\n<td><mark>T</mark></td>\n<td><mark>void</mark></td>\n<td>对类型为T的对象应用操作，包含方法：<code>void accept(T t)</code></td>\n</tr>\n<tr>\n<td><code>Supplier&lt;T&gt;</code></td>\n<td><mark>无</mark></td>\n<td><mark>T</mark></td>\n<td>返回类型为T的对象，包含方法：<code>T get()</code></td>\n</tr>\n<tr>\n<td><code>Function&lt;T, R&gt;</code></td>\n<td><mark>T</mark></td>\n<td><mark>R</mark></td>\n<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)</code></td>\n</tr>\n<tr>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><mark>T</mark></td>\n<td><mark>boolean</mark></td>\n<td>确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：<code>boolean test(T t)</code></td>\n</tr>\n</tbody>\n</table>\n<p>总结：<strong>遇到方法参数类型为以上接口时，可以使用lambda表达式进行优化</strong></p>\n<h3> 2.1 消费型接口 Consumer&lt; T&gt;     void accept(T t)</h3>\n<ul>\n<li><mark><strong>在lambda中使用：T类型参数，无需返回数据</strong></mark></li>\n</ul>\n<p><strong>消费一个指定泛型的数据</strong>（至于具体怎么消费(使用), 需要自定义(输出，计算…） 其数据类型由泛型决定。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.2 生产型接口 Supplier&lt; T&gt;      T get()</h3>\n<ul>\n<li>\n<p><mark><strong>在lambda中使用：无参，返回T类型数据 即可</strong></mark></p>\n</li>\n<li>\n<p>生产型接口，指定接口的泛型是什么类型，那么接口中的get方法<strong>就会生产什么类型的数据</strong></p>\n</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.3 函数型接口 Function&lt;T, R&gt;      R  apply(T t)</h3>\n<ul>\n<li><mark><strong>在lambda中使用：T类型参数，返回R类型数据 即可</strong></mark></li>\n</ul>\n<p>来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.4 断定型接口 Predicate&lt; T&gt;       boolean   test(T t)</h3>\n<p><mark><strong>在lambda中使用：T类型参数，返回boolean类型数据 即可</strong></mark></p>\n<p><strong>对某种类型的数据进行判断</strong>，得到一个boolean值结果</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 四、方法引用与构造器引用</h1>\n<h2> 4.2</h2>\n<h3> 1 方法引用</h3>\n<ul>\n<li>\n<p>使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>\n</li>\n<li>\n<p><strong>通过方法的名字来指向一个方法</strong>，可以认为是Lambda表达式的一个语法糖</p>\n</li>\n<li>\n<p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</p>\n</li>\n<li>\n<p>格式：<code>类(或对象) :: 方法名</code></p>\n</li>\n<li>\n<p>如下三种主要使用情况：</p>\n<ul>\n<li>对象 :: 实例方法名</li>\n<li>类 :: 静态方法名</li>\n<li>类 :: 实例方法名</li>\n</ul>\n</li>\n</ul>\n<h3> 2 构造器引用</h3>\n<p>格式：ClassName :: new //构造器引用</p>\n<p>格式：type[] :: new //数组引用</p>\n<h1> 五、Optional类</h1>\n<p><a href=\"https://www.runoob.com/java/java8-optional-class.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/java/java8-optional-class.html</a></p>\n<h3> 1 概述</h3>\n<ul>\n<li>\n<p>本质上，这是一个<mark>包含有可选值</mark>的包装类</p>\n</li>\n<li>\n<p>Optional 类是一个<strong>可以为null的容器对象</strong>。<mark><strong>如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></mark></p>\n</li>\n<li>\n<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就<strong>不用显式进行空值检测</strong>。Optional\n类的引入很好的解决空指针异常（NullPointerException）。</p>\n</li>\n</ul>\n<h3> 2 创建optional实例</h3>\n<ul>\n<li>使用静态方法<strong>empty()<strong>创建一个</strong>空的Optional对象</strong></li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>明确对象不为null</strong> 的时候使用<strong>of()</strong>，<strong>包含值</strong>的对象</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>如果对象即<strong>可能是null也可能是非 null</strong>，你就应该使用**ofNullable()**方法，<strong>包含值</strong>的对象</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 3 访问对象的值</h3>\n<ul>\n<li><strong>get()方法</strong></li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>检查是否有值的另一个选择是 ifPresent()方法</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4 返回默认值</h3>\n<ul>\n<li><strong>orElse()</strong>：如果有值则返回该值user，否则返回传递给它的参数值user2</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>orElseGet()—— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的**Supplier(供应者)**函数式接口，并将返回其执行结果：</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 5.map()方法</h3>\n",
      "image": "https://typora-imgbed-mrru.oss-cn-chengdu.aliyuncs.com/ruyb/202303171547597.png",
      "date_published": "2022-02-02T00:00:00.000Z",
      "date_modified": "2023-03-27T01:05:52.000Z",
      "authors": [
        {
          "name": "Mr.Ru",
          "url": "https://github.com/ru12321"
        }
      ],
      "tags": [
        "java"
      ]
    }
  ]
}